# -*- mode: ruby -*-
# vi: set ft=ruby :

# If you do "vagrant up --provider=libvirt" after using virtualbox, you may 
# need to do "sudo ip addr flush vboxnetX" to remove the IP address linked 
# to a vboxnetX interface.
# If you do "vagrant up --provider=virtualbox" after libvirt, you may need 
# to do "sudo ip addr flush virbrX" to remove the IP address linked to a
# virbrX interface.

base_memory = ENV["VAGRANT_PYROLYSE_BASE_MEMORY"] || 1024
base_cpus = ENV["VAGRANT_PYROLYSE_BASE_CPU"] || 2

require 'json'
conf_path = "conf.json"
file = open(conf_path)
json_s = file.read
network_config = JSON.parse(json_s)

base_mac_addr = network_config["base"]["mac_addr"]
base_ipv4_addr = network_config["base"]["ipv4_addr"]
base_ipv6_addr = network_config["base"]["ipv6_addr"]
base_network_interface = network_config["base"]["network_interface"]

target_mac_addr_v4 = network_config["target_v4"]["mac_addr"]
target_eth_ipv4_addr_v4 = network_config["target_v4"]["ipv4_addr"]
target_eth_ipv6_addr_v4 = network_config["target_v4"]["ipv6_addr"]

target_mac_addr_v6 = network_config["target_v6"]["mac_addr"]
target_eth_ipv4_addr_v6 = network_config["target_v6"]["ipv4_addr"]
target_eth_ipv6_addr_v6 = network_config["target_v6"]["ipv6_addr"]

# NB: changing values in JSON file will only affect some part of the VagrantFile because some 
# values are also hardcoded in patch file.
bonus_network_ipv4_addr = network_config["bonus_network"]["ipv4_addr"]
bonus_network_ipv6_addr = network_config["bonus_network"]["ipv6_addr"]

tap0_ipv4_addr_v4 = network_config["tap0_v4"]["ipv4_addr"]
target_ipv4_addr = network_config["stack_v4"]["ipv4_addr"]

tap0_ipv6_addr_v6 = network_config["tap0_v6"]["ipv6_addr"]
target_ipv6_addr = network_config["stack_v6"]["ipv6_addr"]

target_family = network_config["target"]["family"]
target_name = network_config["target"]["name"]

base_mac_addr_with_colons = base_mac_addr.scan(/.{1,2}/).join(":")
target_mac_addr_v4_with_colons = target_mac_addr_v4.scan(/.{1,2}/).join(":")
target_mac_addr_v6_with_colons = target_mac_addr_v6.scan(/.{1,2}/).join(":")

Vagrant.configure("2") do |config|
  config.vm.define "base" do |base|
    base.vm.box = "debian/testing64"
    base.vm.box_version = "20250426.1"
    
    base.vm.provider "virtualbox" do |v|
      v.memory = base_memory
      v.cpus = base_cpus
    end
    
    base.vm.network "private_network", name: "vboxnet2", ip: base_ipv4_addr, :mac => base_mac_addr
    base.vm.provision "shell", run: "always", args: base_ipv6_addr, inline: "ip -6 addr add $1/64 dev eth1"
    base.vm.hostname = "base"
    
    base.vm.provider :virtualbox do |vb, override|
      # We deactivate guest because vboxsf is not working if we do not (Debian 10 Buster/virtualbox-6.1 from Oracle repository).
      override.vbguest.auto_update = false
    end
    
    base.vm.synced_folder ".", "/vagrant", disabled: true
    # This setups vboxsf when using VirtualBox.
    base.vm.synced_folder "../../..", "/home/vagrant/pyrolyse"
    # This replace the default rsync method by NFS when using libvirt.
    base.vm.provider :libvirt do |lv, override|
      override.vm.synced_folder "../../..", "/home/vagrant/pyrolyse", type: "nfs"
    end
    
    base.vm.provision "shell", inline: <<-SHELL
      apt update
      
      # IP experiments
      apt install -y --no-install-recommends tcpdump tcpreplay ethtool hping3 python3-scapy
      ethtool -K eth1 tso off gso off rxvlan off txvlan off ufo off gro off lro off tx off sg off rx off
      
      # TCP experiments
      apt install -y --no-install-recommends unzip net-tools parallel jq

      echo "export PYROLYSE_PATH=/home/vagrant/pyrolyse" >> /home/vagrant/.bashrc
    SHELL
    
    base.vm.provision "shell", run: "always", args: base_mac_addr_with_colons, inline: <<-SHELL
      echo "export BASE_MAC_ADDR=$1" >> /home/vagrant/.bashrc
    SHELL
    base.vm.provision "shell", run: "always", args: [base_ipv4_addr, base_ipv6_addr, base_network_interface], inline: <<-SHELL
      echo "export BASE_IPV4_ADDR=$1" >> /home/vagrant/.bashrc
      echo "export BASE_IPV6_ADDR=$2" >> /home/vagrant/.bashrc
      echo "export BASE_NETWORK_INTERFACE=$3" >> /home/vagrant/.bashrc
    SHELL

    base.vm.provision "shell", run: "always", args: [target_mac_addr_v4_with_colons,target_mac_addr_v6_with_colons], inline: <<-SHELL
      echo "export TARGET_MAC_ADDR=$1" >> /home/vagrant/.bashrc # by default, use v4 box for TCP testing 
      echo "export TARGET_MAC_ADDR_V4=$1" >> /home/vagrant/.bashrc
      echo "export TARGET_MAC_ADDR_V6=$2" >> /home/vagrant/.bashrc
    SHELL
    base.vm.provision "shell", run: "always", args: [target_eth_ipv4_addr_v4, target_eth_ipv6_addr_v6], inline: <<-SHELL
      echo "export TARGET_ETH_IPV4_ADDR_V4=$1" >> /home/vagrant/.bashrc
      echo "export TARGET_ETH_IPV6_ADDR_V6=$2" >> /home/vagrant/.bashrc
    SHELL
    base.vm.provision "shell", run: "always", args: [target_ipv4_addr, target_ipv6_addr], inline: <<-SHELL
      echo "export TARGET_IPV4_ADDR=$1" >> /home/vagrant/.bashrc
      echo "export TARGET_IPV6_ADDR=$2" >> /home/vagrant/.bashrc
    SHELL
    base.vm.provision "shell", run: "always", args: [target_family, target_name], inline: <<-SHELL
      echo "export TARGET_FAMILY=$1" >> /home/vagrant/.bashrc
      echo "export TARGET_NAME=$2" >> /home/vagrant/.bashrc
    SHELL
    
    # Adding route for uIP IPv4 stack.
    base.vm.provision "shell", run: "always", args: [bonus_network_ipv4_addr, target_eth_ipv4_addr_v4], inline: <<-SHELL
      ip route add $1/24 via $2
    SHELL
    # Adding route for uIP IPv6 stack.
    base.vm.provision "shell", run: "always", args: [bonus_network_ipv6_addr, target_eth_ipv6_addr_v6], inline: <<-SHELL
      ip route add $1/64 via $2
    SHELL

    # We populate the ARP table so that the Rust TCP testing tool can get the MAC/IP info.
    base.vm.provision "shell", run: "always", args: [target_eth_ipv4_addr_v4, target_mac_addr_v4], inline: <<-SHELL
      arp -s $1 $2
    SHELL

    # Next line is needed to block answer to UDP echo data when testing IP fragmentation.
    base.vm.provision "shell", run: "always", inline: <<-SHELL
      iptables -I OUTPUT -p icmp --icmp-type port-unreachable -j DROP
    SHELL
  end
  
  config.vm.define "targetv4" do |targetv4|
    targetv4.vm.box = "debian/bookworm64"
    targetv4.vm.box_version = "12.20231009.1"
    
    targetv4.vm.network "private_network", name: "vboxnet2", ip: target_eth_ipv4_addr_v4, :mac => target_mac_addr_v4
    targetv4.vm.hostname = "targetv4"
    
    targetv4.vm.synced_folder '.', '/vagrant', disabled: true
    targetv4.vm.synced_folder "patch", "/home/vagrant/patch", type: "rsync", rsync__exclude: ".git/"
    
    targetv4.vm.provider :virtualbox do |vb, override|
      # We deactivate guest because we get this error: "E: Unable to locate package linux-headers-3.16.0-9-amd64".
      override.vbguest.auto_update = false
    end
    
    targetv4.vm.provision "shell", inline: <<-SHELL
      apt update
      apt install -y --no-install-recommends tcpdump net-tools ethtool
      apt install -y --no-install-recommends ca-certificates netbase publicsuffix build-essential openssl unzip wget

      # We modify both uip/unix/main.c and uip/unix/tapdev.c to adapt to the current network setup.
      wget https://github.com/adamdunkels/uip/archive/uip-1-0.zip
      unzip uip-1-0.zip
      mv uip-uip-1-0 /home/vagrant/uip_ipv4
      cd /home/vagrant/uip_ipv4
      patch -p1 < /home/vagrant/patch/uip_ipv4_pyrolyse.patch
      cd /home/vagrant/uip_ipv4/unix
      make -j 4
    SHELL
    
    targetv4.vm.provision "shell", run: "always", inline: <<-SHELL
      # IP experiments - Desactivating offloading
      ethtool -K eth1 tso off gso off rxvlan off txvlan off ufo off gro off lro off tx off sg off rx off
      
      sysctl -w net.ipv4.ip_forward=1
      cd /home/vagrant/uip_ipv4/unix
      echo "Launching uip"
      ./uip > /home/vagrant/log &
      echo "uip launched"
    SHELL
  end
    
  config.vm.define "targetv6" do |targetv6|
    targetv6.vm.box = "debian/bookworm64"
    targetv6.vm.box_version = "12.20231009.1"
    
    targetv6.vm.network "private_network", name: "vboxnet2", ip: target_eth_ipv4_addr_v6, :mac => target_mac_addr_v6
    targetv6.vm.provision "shell", run: "always", args: target_eth_ipv6_addr_v6, inline: "ip -6 addr add $1/64 dev eth1"
    targetv6.vm.hostname = "targetv6"
    
    targetv6.vm.synced_folder '.', '/vagrant', disabled: true
    targetv6.vm.synced_folder "patch", "/home/vagrant/patch", type: "rsync", rsync__exclude: ".git/"
    
    targetv6.vm.provider :virtualbox do |vb, override|
      # We deactivate guest because we get this error: "E: Unable to locate package linux-headers-3.16.0-9-amd64".
      override.vbguest.auto_update = false
    end
    
    # We modify both uip/unix/main.c and uip/unix/tapdev.c to adapt to the current network setup.
    targetv6.vm.provision "shell", inline: <<-SHELL
      apt update
      apt -y --no-install-recommends install tcpdump net-tools ethtool
      apt -y --no-install-recommends install ca-certificates netbase publicsuffix build-essential openssl unzip wget

      wget https://github.com/adamdunkels/uip/archive/uip-1-0.zip
      unzip uip-1-0.zip
      mv uip-uip-1-0 /home/vagrant/uip_ipv6
      cd /home/vagrant/uip_ipv6
      patch -p1 < /home/vagrant/patch/uip_ipv6_pyrolyse_v2.patch
      cd /home/vagrant/uip_ipv6/unix
      make -j 4
    SHELL

    targetv6.vm.provision "shell", run: "always", inline: <<-SHELL
      # IP experiments - Desactivating offloading
      ethtool -K eth1 tso off gso off rxvlan off txvlan off ufo off gro off lro off tx off sg off rx off

      sysctl -w net.ipv6.conf.all.forwarding=1
      cd /home/vagrant/uip_ipv6/unix
      echo "Launching uip"
      ./uip > /home/vagrant/log &
      echo "uip launched"
    SHELL
  end

  # NB: the provided echoserver handle TCP packets on per packet basis, and not as byte flow.
  # Obtained re-assembly policy will ignore overlapping and echo several data sent at the byte index. 
  # Furthermore, uIP API provide the uip_appdata pointer that contains received data.
  # The only additional information is the received data len (with uip_datalen()).
  # It is not possible to obtain the sequence number and handle data overlapping.
  # TCP testing is thus irrelevant.
end

# Test commands (from base)
# IPv4: ping -c 5 "${TARGET_IPV4_ADDR}"
# IPv6: ping -c 5 "${TARGET_IPV6_ADDR}"
# TCP: sudo hping3 -S "${TARGET_IPV4_ADDR}" -p 7
# TCP: nc "${TARGET_IPV4_ADDR}" 7 (type "toto" and observe "toto" sent back)


